@model ViewModel.VideoPlayViewModel
<div class="container">
    <div class="row pt-4 pb-3">
        <div class="col-8">
            <h2 class="text-primary">
                影片列表
            </h2>
        </div> 
        <div class="col-4 text-end"> 
            <a asp-controller="VideoPlayer" asp-action="Upload" class="btn btn-primary">
                <i class="bi bi-plus-circle"></i> 新增影片
            </a>
        </div>
    </div>
    @if (Model.VideoList != null && Model.VideoList.Any())
    {
        @foreach (var obj in Model.VideoList)
        {
            <div class="row row-cols-1 row-cols-md-4 g-4">

                <div class="col">
                    <div class="card">
                        <img class="card-img-top video-thumbnail" data-video-url="@obj.VideoUrl" id="img-@obj.Id" src="~/Images/1.jpg" alt="@obj.Name 縮圖">
                        <video id="video-@obj.Id" preload="metadata"  crossorigin="anonymous" style="display:none;"></video>
                        <canvas id="canvas-@obj.Id" style="display:none;"></canvas>
                        <div class="card-body">
                            <h5 class="card-title">@obj.Name</h5> 
                            <p class="card-text">@obj.introduce</p>
                            <a asp-controller="VideoPlayer" asp-action="PlayVIdeo" asp-route-Id="@obj.Id" class="btn btn-primary">觀看影片</a>
                            <a asp-controller="VideoPlayer" asp-action="Upload" asp-route-Id="@obj.Id" class="btn btn-primary">修改標題</a>
                        </div>
                    </div>
                </div>

            </div>
        }
    }
    else
    {
        <p>目前沒有影片可供顯示。</p>
    }
</div> 

<!-- 載入 JavaScript 來處理縮圖生成 -->
@section Scripts {
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // 找到所有待處理的縮圖圖片元素
            const thumbnailImages = document.querySelectorAll('.video-thumbnail');

            thumbnailImages.forEach(imgElement => {
                const videoUrl = imgElement.dataset.videoUrl; // 從 data-video-url 屬性取得影片 URL
                const videoId = imgElement.id.replace('img-', ''); // 從 img 元素的 ID 解析出影片 ID

                // 取得對應的 video 和 canvas 元素
                const videoElement = document.getElementById(`video-${videoId}`);
                const canvasElement = document.getElementById(`canvas-${videoId}`);

                // 如果任何元素沒找到，或影片 URL 無效，則跳過
                if (!videoElement || !canvasElement || !videoUrl || videoUrl.trim() === '') {
                    console.warn(`Required elements or video URL not found for ID: ${videoId}`);
                    // 可以設定一個錯誤或預設圖片
                    imgElement.src = '~/Images/error_placeholder.jpg'; // 請確保這個圖片存在
                    return;
                }

                const context = canvasElement.getContext('2d');

                // 設置影片來源
                videoElement.src = videoUrl;

                // 監聽影片載入元資料完成事件
                // 當影片的元資料 (例如尺寸、時長) 載入完成時觸發
                videoElement.addEventListener('loadedmetadata', () => {
                    // 設定 canvas 的尺寸與影片相同，以確保截圖比例正確
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;

                    // 嘗試跳轉到影片的某一秒 (例如第 2 秒)，作為縮圖的來源幀
                    // 確保 currentTime 不超過影片總時長
                    videoElement.currentTime = Math.min(2, videoElement.duration - 0.1); // -0.1 是為了避免跳到影片末尾的黑畫面
                });

                // 監聽影片跳轉完成事件 (當 currentTime 設定後，影片準備好該幀時觸發)
                videoElement.addEventListener('seeked', () => {
                    // 將影片的當前幀繪製到 canvas 上
                    context.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);

                    // 將 canvas 內容轉換為圖片的 Data URL (例如 JPEG 格式)
                    // 第二個參數 0.8 是品質參數 (0-1)，可以根據需要調整
                    const dataURL = canvasElement.toDataURL('image/jpeg', 0.8);

                    // 將 Data URL 設定為 img 標籤的 src
                    imgElement.src = dataURL;

                    // 為了節省資源，生成縮圖後將 video 和 canvas 元素從 DOM 中移除或清空 src
                    // 這樣它們就不會持續佔用記憶體或載入影片數據
                    videoElement.removeAttribute('src'); // 移除 src 停止載入
                    videoElement.load(); // 重新載入，釋放資源
                    videoElement.remove(); // 從 DOM 中移除 video 元素
                    canvasElement.remove(); // 從 DOM 中移除 canvas 元素
                }, { once: true }); // 使用 { once: true } 確保事件只觸發一次，避免重複處理

                // 處理影片載入錯誤
                videoElement.addEventListener('error', (e) => {
                    console.error('Error loading video:', videoUrl, e);
                    // 如果影片載入失敗，設定一個錯誤佔位圖片
                    imgElement.src = '~/Images/error_placeholder.jpg'; // 請確保這個圖片存在
                    videoElement.remove(); // 出錯也移除元素
                    canvasElement.remove();
                }, { once: true });

                // 在 Chrome 等瀏覽器中，如果影片不是自動播放或靜音，可能需要 user gesture 才能載入
                // 但是對於僅獲取 metadata 和縮圖，preload="metadata" 通常足夠。
                // videoElement.load() 已經在 loadedmetadata 事件後被呼叫，所以這裡不需要重複呼叫。
            });
        });
    </script>
}